Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject methodsFor: 'instance-methods' stamp: 'Oranichu 12/17/2019 21:17'!isKindOf: aClassOrInterface	((super isKindOf: aClassOrInterface) or: (self class behavesLike includes: aClassOrInterface)) ifTrue: [		^true.	].	^false.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/17/2019 15:44'!ambiguities	| allFunctionsCollection temp result |	allFunctionsCollection := SortedCollection new.	self behavesLike do: [ :intr |		allFunctionsCollection addAll: (intr methodDict keys).	].	result := Set new.	allFunctionsCollection do: [ :func |		temp := self getNumberOfOccurence: allFunctionsCollection for: func.		(temp > 1) ifTrue: [ result add: func. ].	].	result := result asSortedCollection.	result := result sortBlock: [:func1 :func2 | (func1 printString) < (func2 printString) ]. 	^result.! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/16/2019 19:34'!behavesLike| temp_set |	temp_set := Set new.	"defention 4 of behaves like"	(isInterface) ifTrue: [		temp_set add: self.	].		(self ~= MyObject) ifTrue: [		"defention 1 of behaves like"		temp_set addAll: behavesLike.	].	(super ~= MyObject) ifTrue: [		"defention 2 of behaves like"		temp_set addAll: self superclass behavesLike.	].	"defention 3 of behaves like"	behavesLike do: [ :temp_class |		(temp_class ~= MyObject) ifTrue: [			temp_set addAll: temp_class behavesLike.		].				].		^temp_set.! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/17/2019 13:29'!checkIfDefault: aMethodName	(aMethodName size < 7) ifTrue: [		^false.	]. 	((aMethodName copyFrom: 1 to: 7) = 'default') ifFalse: [		^false.	].	^true.! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/17/2019 18:57'!checkIfReciveArgs: aMethodName	((aMethodName indexOf: $: ifAbsent: [0]) = 0) ifTrue: [		^false.		" : is absent from method name, method doesn't take arguments"	].	^true.	! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/17/2019 22:28'!compile: aSourceCode| firstLine |	firstLine := (aSourceCode findTokens: String cr, String lf) at: 1.	 (self checkIfDefault: firstLine) ifFalse: [		(self isInterface) ifTrue:[			((aSourceCode lines) size > 1) ifTrue:[				AssertionFailure signal: ('Interfaces are not allowed to have methods that define behavior!!').			].		].	].		^super compile: aSourceCode.	! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/20/2019 12:40'!compile: aSourceCode where: anOrderedCollection	| cLines sLines iIndex cArguments iLineToInject  |	cArguments := self getArguments: aSourceCode.	cLines := aSourceCode findTokens: String cr, String lf.	"check if arugment number is equal to anOrderedCollection"	((cArguments size) = (anOrderedCollection size)) 	ifFalse: [		AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!'.	] ifTrue: [		iIndex := 1.		" Helper function that checks if theres a local var line."		iLineToInject := self getStartLineNumber: aSourceCode.		cArguments do: [ :arg |			| sLine |			"if arg = Nil  (in the input ordered collection) continue to next arg"			((anOrderedCollection at: iIndex) isNil) ifFalse: [				sLine := '	(', arg, ' isKindOf: ', (anOrderedCollection at: iIndex), ') ifFalse: [ AssertionFailure signal: ''Type mismatch!! Argument ', (iIndex printString), ' should be ', (anOrderedCollection at: iIndex), '''].'.				cLines add: sLine afterIndex: iLineToInject.				iLineToInject := iLineToInject + 1.			].				iIndex := iIndex+1.		].		sLines := cLines joinSeparatedBy: String cr, String lf.		self compile: sLines.	].! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/20/2019 10:55'!getAllDefaultMethods	| allDefaultMethods |	allDefaultMethods := Set new.	self behavesLike do: [:interface |		interface selectors do: [:method |			(self checkIfDefault: method asString) ifTrue: [				allDefaultMethods add: ((interface decompile: method) asString).			].		].	].	^allDefaultMethods.! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/8/2019 11:43'!getArguments: aSourceCode| result cArguments cLines sFirstLine index| 	" Helper function that returns the arguments as an Ordered Collection "	cLines := aSourceCode findTokens: String cr, String lf. 	sFirstLine := cLines at: 1.	cArguments := sFirstLine findTokens: ':'.	cArguments := cArguments joinSeparatedBy: ' '.	cArguments := cArguments findTokens: ' '.	index := 1.	result := OrderedCollection new.	cArguments do: [ :word |		(index \\\ 2 = 0) ifTrue: [result add: word].		index := index + 1.	].	^result.	! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/17/2019 15:42'!getNumberOfOccurence: aCollection for: elementToCheck	| counter |	counter := 0.	aCollection do: [ :element |		(element = elementToCheck) ifTrue: [			counter := counter + 1.				].	].	^counter.! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/17/2019 22:18'!getSecondLine: aMethod	^((aMethod findTokens: String cr, String lf) at: 2).	! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/20/2019 11:01'!getStartLineNumber: aSourceCode 	| cLines  sSecLine chFirstCharInLine |	" Helper function to let us know where we want to start injecting the type check conditions "	cLines := aSourceCode findTokens: String cr, String lf. 	(cLines size < 2) ifTrue:[		^1.	].	sSecLine := cLines at: 2.	sSecLine := sSecLine findTokens: String tab.	sSecLine := sSecLine joinSeparatedBy: ' '.	chFirstCharInLine := (sSecLine findTokens: ' ') at: 1.	( chFirstCharInLine = '|' ) ifTrue: [^2.].	^1.	! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/17/2019 17:31'!isAbstruct	| funcsToImplement  |	funcsToImplement := Set new.	self behavesLike do: [:interface |		(interface isFunctionsImplemented: self) ifFalse: [			^true.		].	].	^false. 	! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/20/2019 12:24'!isFunctionsImplemented: aClass	| cMyFuncs |	cMyFuncs := self methodDict keys.	cMyFuncs do: [:func |		(self checkIfDefault: func) ifFalse:[			(aClass canUnderstand: func) ifFalse: [				^false.			].		]	].	^true.! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/20/2019 12:28'!isImplemented	(self isInterface) ifFalse: [		AssertionFailure signal: (self name , ' is not an interface!!').	].	self behavesLike do: [ :interface | 		(interface recSearchForImplemnt: MyObject) ifFalse:[			^false.		].	].	^true.! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/8/2019 14:57'!isInterface	 ^isInterface.! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/17/2019 19:36'!new	(self isInterface) ifTrue: [		AssertionFailure signal: ('Interfaces can not be instantiated!!').	].	(self isAbstruct) ifTrue: [		AssertionFailure signal: ('Can not instantiate an Abstract class!!').	].		^super new.! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/20/2019 12:26'!recSearchForImplemnt: curr	" need to get all functions to implements"	curr subclasses do: [:subClass |		(subClass isInterface) ifFalse:[			(subClass behavesLike includes: self) ifTrue: [				((self isFunctionsImplemented: subClass) and: (self ~= subClass)) ifTrue: [					^true.				].			].		].		(self recSearchForImplemnt: subClass) ifTrue: [			^true.		].	].	^false.! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/17/2019 20:46'!subclass: aSubclassName	instanceVariableNames: instVarNames	classVariableNames: classVarNames	poolDictionaries: poolDictionaries	category: aCategoryName		^self subclass: aSubclassName		isInterface: false		behavesLike: {}		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: poolDictionaries		category: aCategoryName.! !!MyObject class methodsFor: 'class-methods' stamp: 'Oranichu 12/20/2019 11:16'!subclass: aSubclassName	isInterface: isInterface	behavesLike: aCollection	instanceVariableNames: instVarNames	classVariableNames: classVarNames	poolDictionaries: poolDictionaries	category: aCategoryName	| newInstance |		(self ~= MyObject and: isInterface = true) ifTrue: [		AssertionFailure signal: 'Interfaces must derive from MyObject!!'.	].	(isInterface = true and: instVarNames ~= '') ifTrue: [		AssertionFailure signal: 'Interfaces can not have state!!'.	].	(self isInterface = true and: isInterface = false) ifTrue: [		AssertionFailure signal: 'Classes can not derive from an interface!!'.	].	aCollection do: [ :c |		 (c isInterface = false) ifTrue: [			AssertionFailure signal: 'Can not behave like a non-interface!!'.		].	].		newInstance := (ClassBuilder new)		superclass: self		subclass: aSubclassName		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: poolDictionaries		category: aCategoryName.				newInstance instVarNamed: 'isInterface' put: isInterface.	newInstance instVarNamed: 'behavesLike' put: aCollection.		" make sure class knows all of the default methods he bevhas like"	(isInterface) ifFalse: [		newInstance getAllDefaultMethods do: [ :defaultMethod |			newInstance compile: defaultMethod.		].	]. 		^newInstance.! !